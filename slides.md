# 生成AI駆動業務システム開発カリキュラム

---

## スライド1：カリキュラム概要と学習ゴール

### 対象者
- **営業部門・業務部門の皆さま**
- プログラミング未経験でも大丈夫！
- 「業務を効率化したい」という想いがあればOK

### このカリキュラムで学ぶこと

**前半：ローカルツール開発**
- 自分のPCで動くPythonツールを作成
- OpenAI APIを活用したデータ処理
- すぐに自分の業務で使えるツール

**後半：Webアプリ開発**
- ブラウザで動くWebアプリケーション
- クラウド（Render）へのデプロイ
- 部門全体で共有・利用できるシステム

### 実際に作るもの：「営業日報AI整理ツール」

**ローカル版（Phase 1）**
- 自由記述の営業日報テキストを読み込み
- AIが自動で情報を抽出（顧客名、商談内容、見込み金額など）
- Excelファイルに整理して出力

**Web版（Phase 2）**
- ブラウザから日報を入力
- リアルタイムでAI解析・構造化
- チーム全員でデータ共有
- ダッシュボードで部門全体の状況を可視化

### 最終ゴール
受講後、あなた自身で以下ができるようになります：
- ✅ 日々の業務課題を技術的に解決できる
- ✅ AIを活用した業務効率化ツールを自作できる
- ✅ チーム全体で使えるWebサービスを構築・運用できる

**あなたの業務知識 × AI技術 = 最強の業務効率化**

---

## スライド2：なぜAI活用開発なのか？

### プログラミングの常識が変わった

**従来（2023年まで）**
- プログラミングには専門知識が必須
- 習得に数年かかる
- エンジニアに依頼するしかない
- 細かい仕様変更も時間とコストがかかる

**現在（2024年以降）**
- AIがコードを生成してくれる時代
- 日本語で指示するだけで動くプログラムができる
- 自分の業務を理解している人が直接作れる
- 修正も即座に対応可能

### Cursorの登場で何が変わったか

**Cursor = AI搭載の開発環境**
- 「〇〇する機能を作って」と日本語で指示
- AIがコード全体を生成
- エラーが出ても、AIが原因を分析して修正案を提示
- プログラミング未経験でも、実用的なシステムが作れる

### なぜ「自分で作る」のか？

**理由1：業務を一番理解しているのは自分**
- エンジニアに説明する手間が不要
- 現場の細かいニーズに即対応
- 試行錯誤しながら最適な形を作れる

**理由2：圧倒的なスピード感**
- 依頼・見積もり・開発待ちの時間ゼロ
- 思いついたその日に作り始められる
- 改善サイクルが高速化

**理由3：コスト削減**
- 外注費不要（OpenAI APIの費用のみ、月数百円〜）
- 社内で継続的に改善可能
- 複数のツールを次々に作れる

### 実際の成功事例

**営業部門の事例**
- 月次報告書の作成時間：8時間 → 30分
- AIが営業データを自動集計・グラフ化
- 作成者：営業部の非エンジニア社員

**業務部門の事例**
- 契約書チェック業務：1件30分 → 5分
- AIが契約書から重要条項を自動抽出
- 作成者：法務部の非エンジニア担当者

**あなたも同じことができます！**

---

## スライド3：Cursorと生成AIの基礎

### 生成AIとは？

**定義**
- 大量のデータから学習したAIが、新しいコンテンツを「生成」する技術
- テキスト、画像、コード、音楽など様々なものを作り出せる

**プログラミングでの活用**
- 「顧客管理システムを作って」→ AIがコード全体を生成
- 「エラーが出た」→ AIが原因分析と修正案を提示
- 「この機能を追加して」→ AIが既存コードに統合

**代表的な生成AI**
- ChatGPT（OpenAI）
- Claude（Anthropic）
- GitHub Copilot
- Cursor（開発に特化したAI IDE）

### Cursorとは？

**AIペアプログラミングIDE**
- IDE = 統合開発環境（プログラムを書くためのアプリ）
- AIが常にあなたをサポート
- まるで優秀なエンジニアが隣にいるような感覚

**主な機能**

**1. Chat機能**
- AIに質問できる
- 「このエラーの原因は？」
- 「このコードを説明して」
- コードの一部を選択して質問も可能

**2. Composer機能（最重要！）**
- 複数のファイルを同時に編集
- 「営業日報を読み込んでExcelに出力する機能を作って」
- AIが必要なファイルを全て作成・編集してくれる
- 大規模な変更も一度に実行可能

**3. Agent機能**
- AIが自律的にタスクを実行
- ファイル検索、編集、実行まで自動化
- より複雑な開発作業をAIに任せられる

### AIペアプログラミングの実際

**従来のプログラミング**
```
1. 自分でコードを1行ずつ書く
2. エラーが出る
3. ドキュメントを読んで原因を調べる
4. 試行錯誤で修正
5. 何時間もかかる
```

**Cursorでのプログラミング**
```
1. Composerで「〇〇を作って」と指示
2. AIが数秒〜数分でコード生成
3. エラーが出たらAIに聞く
4. AIが原因と修正案を即座に提示
5. 数分で完成
```

**あなたの役割**
- ❌ コードを書くこと（AIがやる）
- ✅ 何を作りたいか明確にすること
- ✅ AIが作ったものが正しいか確認すること
- ✅ 業務要件を正確に伝えること

### デモ：Cursorで簡単なコードを生成

**やりたいこと**
「Excelファイルから顧客リストを読み込んで、メールアドレスだけを抽出して表示する」

**Composerへの指示例**
```
Excelファイル（customers.xlsx）から顧客データを読み込み、
メールアドレスのカラムだけを抽出して画面に表示する
Pythonスクリプトを作成してください。
```

**結果**
- AIが必要なライブラリをインストールするコマンドを提示
- Pythonスクリプトファイルを自動生成
- 実行方法も説明してくれる
- 所要時間：約30秒

**これだけです！**

---

## スライド4：ローカルツール開発の流れ

### なぜローカルツールから始めるのか？

**理由1：シンプルで理解しやすい**
- 自分のPC上で完結
- サーバーやデータベースが不要
- まずは基本を理解

**理由2：すぐに実務で使える**
- 作ったその日から使える
- 自分の業務効率化に直結
- 成功体験を早く得られる

**理由3：Web化の基礎になる**
- ここで学んだ内容がWeb版に活きる
- 段階的にステップアップ

### 開発の4つのPhase

**Phase 1：何を作るか決める（要件定義）**

まず明確にすること：
- どんな課題を解決したいか？
- 現状の業務フローは？
- 入力は何か？（テキスト、Excel、PDFなど）
- 出力は何か？（Excel、レポート、グラフなど）

**例：営業日報の課題**
```
【現状の課題】
・営業担当が自由形式でテキストを書いている
・内容がバラバラで情報の抽出が困難
・月末の集計に丸一日かかる
・見込み案件の優先順位が不明確

【解決したいこと】
・日報から重要情報を自動抽出
・Excelで一覧化・集計
・優先度を自動判定
```

**Phase 2：データ設計（どんな情報を扱うか）**

抽出したい情報を定義：

**営業日報から抽出する項目**
```
1. 基本情報
   - 報告日
   - 営業担当者名

2. 顧客情報
   - 顧客名（会社名）
   - 担当者名
   - 業種

3. 商談情報
   - 商談内容（要約）
   - 提案商品/サービス
   - 見込み金額
   - 確度（A/B/Cランク）

4. アクション
   - 次回訪問予定日
   - 次回のアクション内容
   - 課題・懸念事項
```

**Excelの出力形式**
```
| 日付 | 担当者 | 顧客名 | 商談要約 | 見込み金額 | 確度 | 次回アクション |
```

**Phase 3：Cursorで実装**

**ステップ1：プロジェクトフォルダを作成**
```
sales-report-tool/
  ├── main.py          # メインプログラム
  ├── reports/         # 日報テキストを入れるフォルダ
  ├── output/          # 出力Excelを保存するフォルダ
  └── requirements.txt # 必要なライブラリ一覧
```

**ステップ2：Composerで指示**

Cursorを開いて、Composerに以下のように指示：

```
営業日報テキストファイルから情報を抽出して
Excelに出力するPythonツールを作成してください。

【機能】
1. reports/フォルダ内のテキストファイルを読み込む
2. OpenAI APIで以下の情報を抽出：
   - 顧客名、担当者名、商談要約、見込み金額、確度、次回アクション
3. openpyxlを使ってExcelファイルに出力
4. output/フォルダに「営業日報まとめ_日付.xlsx」として保存

【入力例】
「本日、ABC株式会社の田中様を訪問。新システム導入の提案を実施。
予算は約500万円で、来月の役員会で検討とのこと。
確度はBランク。次回は2週間後に再訪問し、詳細見積を提示予定。」

【出力】
Excelの各列に構造化されたデータ
```

**ステップ3：AIがコード生成**
- 必要なファイルを全て作成
- 実行方法を説明してくれる

**Phase 4：動作確認とデバッグ**

**テスト実行**
```
1. サンプルの日報テキストを用意
2. プログラムを実行
3. 出力されたExcelを確認
```

**エラーが出たら？**
- エラーメッセージをコピー
- Cursorのチャットに貼り付けて「このエラーの原因と修正方法を教えて」
- AIが原因分析と修正案を提示
- 修正を適用して再実行

**完成！**
- 実際の業務で使ってみる
- 改善点があればCursorに指示して修正

---

## スライド5：OpenAI APIとデータ抽出

### OpenAI APIとは？

**API（Application Programming Interface）**
- プログラムから他のサービスを利用する仕組み
- OpenAI APIを使うと、ChatGPTの機能をプログラム内で使える

**できること**
- テキスト生成
- 情報抽出（今回のメイン用途）
- 要約
- 翻訳
- 分類

**料金**
- 従量課金制（使った分だけ）
- テキスト処理：1,000トークンあたり数円
- 営業日報ツールの場合：月数百円程度

### 情報抽出の仕組み

**従来の方法（プログラムで抽出）**
```
課題：
- 「顧客名：ABC株式会社」のように決まった形式なら抽出可能
- でも実際の日報は自由記述
- 「今日はABC株式会社に行った」
- 「ABC社訪問」
- 「A社（ABC株式会社）」
→ パターンが無限にあり、プログラムで対応困難
```

**AIを使う方法**
```
メリット：
- 自由記述のテキストでもOK
- AIが文脈を理解して情報を抽出
- パターン定義不要
```

### プロンプトエンジニアリングの基礎

**プロンプト = AIへの指示文**

良いプロンプトの条件：
1. **具体的**：何をしてほしいか明確に
2. **構造化**：出力形式を指定
3. **例示**：できれば例を示す

**悪い例（あいまい）**
```
日報から情報を取り出して
```

**良い例（具体的）**
```
以下の営業日報テキストから、下記の情報をJSON形式で抽出してください。

【抽出する情報】
- 顧客名（会社名）
- 担当者名
- 商談内容（30文字程度に要約）
- 見込み金額（数値のみ、不明な場合は0）
- 確度（A/B/Cのいずれか、不明な場合はC）
- 次回アクション（簡潔に）

【出力形式】
{
  "customer_name": "顧客名",
  "contact_person": "担当者名",
  "summary": "商談要約",
  "amount": 数値,
  "probability": "A or B or C",
  "next_action": "次回アクション"
}

【日報テキスト】
（ここに日報が入る）
```

### Cursorでの実装方法

**Composerへの指示**
```
OpenAI APIを使って営業日報から情報を抽出する関数を作成してください。

【仕様】
1. 関数名：extract_info_from_report
2. 引数：report_text（日報のテキスト）
3. 戻り値：辞書型（抽出した情報）
4. 使用モデル：gpt-4o-mini
5. プロンプトは上記の「良い例」を使用
```

**AIが生成するコード**
- OpenAI APIの呼び出しコード
- エラーハンドリング
- JSON解析
- 全て自動で作ってくれます

### 実践：営業日報からの情報抽出

**サンプル日報**
```
2024年11月5日 営業日報（担当：山田）

本日は午前中にABC株式会社の田中部長を訪問しました。
新しい在庫管理システムの提案を行い、高い関心を示していただきました。
現在使っているシステムが古く、リアルタイム性に課題があるとのこと。

予算は500-700万円程度を想定しており、来月の経営会議で
正式に検討されるそうです。競合は2社あるようですが、
当社の提案内容に魅力を感じていただいている印象です。

次回は11月20日に再訪問し、詳細見積と導入スケジュールを
提示する予定です。
```

**AIによる抽出結果**
```json
{
  "customer_name": "ABC株式会社",
  "contact_person": "田中部長",
  "summary": "在庫管理システムの提案、高い関心",
  "amount": 6000000,
  "probability": "B",
  "next_action": "11/20に詳細見積提示"
}
```

**ポイント**
- 金額は範囲の中央値を算出
- 確度は文脈から判断（「高い関心」「経営会議で検討」→Bランク）
- 人間が読むのと同じように理解している

**このデータをExcelに出力すれば完成！**

---

## スライド6：テーブル設計とデータベース

### なぜデータベースを学ぶのか？

**ローカルツール（Excel出力）の限界**
- 毎回新しいExcelファイルが作られる
- 過去データの蓄積・検索が困難
- 複数人で同時に使えない
- データの更新・削除が面倒

**Webアプリにはデータベースが必須**
- データを永続的に保存
- 高速な検索・フィルタリング
- 複数ユーザーが同時アクセス可能
- データの更新・削除が容易

### データベースの基礎概念

**データベース = データの倉庫**

**テーブル = Excelのシートのようなもの**
```
顧客テーブル
| ID | 顧客名 | 業種 | 担当者 |
|----|--------|------|--------|
| 1  | ABC社  | 製造 | 田中部長|
| 2  | XYZ社  | 小売 | 佐藤氏 |
```

**カラム（列）= データの項目**
- ID、顧客名、業種など

**レコード（行）= 1件のデータ**
- 「ID=1, 顧客名=ABC社...」

**主キー（Primary Key）**
- 各レコードを一意に識別する項目
- 通常はID
- 重複不可

### テーブル設計の考え方

**営業日報システムで必要なデータは？**

考え方：
1. どんな「モノ」があるか？ → テーブルになる
2. それぞれに何の情報があるか？ → カラムになる
3. モノ同士の関係は？ → リレーションになる

**営業日報システムの場合**

**「モノ」を洗い出す**
- 顧客
- 商談
- 営業担当者

**テーブル構造**

**1. 顧客テーブル（customers）**
```
| カラム名 | データ型 | 説明 |
|----------|----------|------|
| id | 整数 | 顧客ID（主キー）|
| name | 文字列 | 顧客名（会社名）|
| industry | 文字列 | 業種 |
| created_at | 日時 | 登録日時 |
```

**2. 商談テーブル（deals）**
```
| カラム名 | データ型 | 説明 |
|----------|----------|------|
| id | 整数 | 商談ID（主キー）|
| customer_id | 整数 | 顧客ID（外部キー）|
| sales_rep | 文字列 | 営業担当者名 |
| contact_person | 文字列 | 顧客側担当者 |
| summary | 文字列 | 商談要約 |
| amount | 整数 | 見込み金額 |
| probability | 文字列 | 確度（A/B/C）|
| next_action | 文字列 | 次回アクション |
| next_date | 日付 | 次回予定日 |
| report_date | 日付 | 報告日 |
| created_at | 日時 | 登録日時 |
```

### リレーション（関係性）

**顧客と商談の関係**
```
1人の顧客 ← 複数の商談

【例】
ABC株式会社（顧客ID=1）
  ├─ 在庫管理システムの商談（商談ID=1）
  ├─ 会計システムの商談（商談ID=2）
  └─ CRMシステムの商談（商談ID=3）
```

**外部キー（Foreign Key）**
- 商談テーブルの `customer_id` が顧客テーブルの `id` を参照
- これにより「この商談はどの顧客のものか」が分かる

**データの取得例**
```sql
「ABC株式会社」の全ての商談を取得：

SELECT * FROM deals 
WHERE customer_id = (
  SELECT id FROM customers WHERE name = 'ABC株式会社'
)
```

### 正規化の基本

**正規化 = データの重複をなくす**

**悪い例（非正規化）**
```
商談テーブル
| ID | 顧客名 | 業種 | 担当者 | 商談内容 |
|----|--------|------|--------|----------|
| 1  | ABC社  | 製造 | 田中   | 在庫管理 |
| 2  | ABC社  | 製造 | 田中   | 会計     |
| 3  | ABC社  | 製造 | 田中   | CRM      |

問題：
- 顧客名、業種が重複
- ABC社の業種が変わったら全て更新が必要
```

**良い例（正規化）**
```
顧客テーブル
| ID | 顧客名 | 業種 |
|----|--------|------|
| 1  | ABC社  | 製造 |

商談テーブル
| ID | 顧客ID | 担当者 | 商談内容 |
|----|--------|--------|----------|
| 1  | 1      | 田中   | 在庫管理 |
| 2  | 1      | 田中   | 会計     |
| 3  | 1      | 田中   | CRM      |

メリット：
- データの重複なし
- 更新が1箇所でOK
```

### Webアプリ化のためのデータ設計

**ローカル版（Excel）**
```
1回の実行で1つのExcelファイル
→ 毎回新規作成、過去データは別ファイル
```

**Web版（データベース）**
```
全てのデータを1つのデータベースに蓄積
→ 検索、集計、分析が容易
→ リアルタイムでチーム全員が閲覧可能
```

**使用するデータベース**
- 開発時：SQLite（ファイルベース、簡単）
- 本番環境：PostgreSQL（Renderが提供）

**Cursorに任せる**
- テーブル作成のコード
- データの追加・取得・更新・削除のコード
- 全てCursorが生成してくれます！

---

## スライド7：Webアプリ化の基本

### ローカルツールとWebアプリの違い

**ローカルツール**
```
[自分のPC]
  ├─ Pythonスクリプト
  ├─ 入力ファイル
  └─ 出力ファイル

特徴：
✓ 自分だけが使える
✓ 自分のPCでのみ動作
✓ ファイルベース
✗ 他の人と共有できない
✗ 外出先からアクセス不可
```

**Webアプリ**
```
[クラウドサーバー（Render）]
  ├─ Webアプリケーション
  ├─ データベース
  └─ API

↑↓ インターネット

[営業担当A] [営業担当B] [マネージャー]
 ブラウザ    ブラウザ     ブラウザ

特徴：
✓ チーム全員が使える
✓ どこからでもアクセス可能
✓ データが一元管理される
✓ リアルタイムで情報共有
✓ スマホからも利用可能
```

### Webアプリの構成

**3層アーキテクチャ**

**1. フロントエンド（見える部分）**
```
役割：
- ユーザーが操作する画面
- データの入力・表示

技術：
- HTML（構造）
- CSS（デザイン）
- JavaScript（動き）

例：
- 日報入力フォーム
- 商談一覧表
- ダッシュボード
```

**2. バックエンド（処理する部分）**
```
役割：
- ビジネスロジック
- OpenAI APIとの連携
- データベース操作

技術：
- Python（Flask or FastAPI）

例：
- 日報テキストをAIで解析
- データベースに保存
- 検索・集計処理
```

**3. データベース（保存する部分）**
```
役割：
- データの永続化
- 複雑な検索・集計

技術：
- PostgreSQL

例：
- 顧客データ
- 商談データ
- ユーザーデータ
```

### データの流れ

**日報入力の流れ**
```
1. [フロントエンド] ユーザーが日報テキストを入力
   ↓
2. [バックエンド] テキストを受け取り、OpenAI APIで解析
   ↓
3. [バックエンド] 抽出した情報をデータベースに保存
   ↓
4. [フロントエンド] 「登録完了」を表示
```

**商談一覧表示の流れ**
```
1. [フロントエンド] 「一覧を見る」ボタンをクリック
   ↓
2. [バックエンド] データベースから商談データを取得
   ↓
3. [バックエンド] データを整形してフロントエンドに返す
   ↓
4. [フロントエンド] 表形式で表示
```

### 画面設計の基本

**営業日報AI整理ツール（Web版）の画面構成**

**1. ダッシュボード画面（トップページ）**
```
┌─────────────────────────────────────┐
│ 営業日報AI整理ツール              │
├─────────────────────────────────────┤
│ 【今月のサマリー】                 │
│ ・登録件数：45件                   │
│ ・見込み総額：2.3億円              │
│ ・確度A案件：5件（3,500万円）      │
├─────────────────────────────────────┤
│ 【最近の商談】                     │
│ 11/5  ABC社  在庫管理  600万  B    │
│ 11/4  XYZ社  CRM      400万  A     │
│ ...                                │
├─────────────────────────────────────┤
│ [新規日報登録] [商談一覧] [分析]   │
└─────────────────────────────────────┘
```

**2. 日報登録画面**
```
┌─────────────────────────────────────┐
│ 営業日報登録                       │
├─────────────────────────────────────┤
│ 日報テキスト：                     │
│ ┌───────────────────────────────┐ │
│ │本日ABC社の田中部長を訪問...   │ │
│ │                               │ │
│ └───────────────────────────────┘ │
│                                    │
│ [AIで解析して登録]                 │
└─────────────────────────────────────┘

↓ ボタンを押すと...

┌─────────────────────────────────────┐
│ 解析結果を確認してください         │
├─────────────────────────────────────┤
│ 顧客名：ABC株式会社                │
│ 担当者：田中部長                   │
│ 見込み金額：600万円                │
│ 確度：B                            │
│ ...                                │
│                                    │
│ [修正する] [このまま登録]          │
└─────────────────────────────────────┘
```

**3. 商談一覧画面**
```
┌─────────────────────────────────────┐
│ 商談一覧                           │
├─────────────────────────────────────┤
│ フィルター：                       │
│ 確度：[全て▼] 期間：[今月▼]       │
├─────────────────────────────────────┤
│ 日付  │顧客名│商談内容│金額│確度  │
│ 11/5  │ABC社 │在庫管理│600万│B   │
│ 11/4  │XYZ社 │CRM    │400万│A   │
│ ...                                │
├─────────────────────────────────────┤
│ [Excelエクスポート]                │
└─────────────────────────────────────┘
```

### 画面遷移図

```
[ダッシュボード]
    │
    ├─→ [日報登録画面]
    │      │
    │      └─→ [確認画面] ─→ [完了] ─→ [ダッシュボード]
    │
    ├─→ [商談一覧画面]
    │      │
    │      └─→ [商談詳細画面]
    │             │
    │             └─→ [編集画面] ─→ [更新完了]
    │
    └─→ [分析画面（グラフ表示）]
```

### 実例：営業日報ツールのWeb版構成

**ディレクトリ構成**
```
sales-report-web/
  ├── app.py              # メインアプリケーション（Flask）
  ├── models.py           # データベースモデル定義
  ├── routes.py           # URL処理
  ├── ai_extractor.py     # OpenAI API処理
  ├── templates/          # HTMLファイル
  │   ├── dashboard.html
  │   ├── report_form.html
  │   └── deals_list.html
  ├── static/             # CSS, JavaScript
  │   ├── style.css
  │   └── app.js
  ├── requirements.txt
  └── .env               # 環境変数（APIキーなど）
```

**Cursorへの指示例**
```
営業日報AI整理ツールのWebアプリケーションを作成してください。

【技術スタック】
- Flask
- SQLite（開発時）
- OpenAI API
- Bootstrap（デザイン）

【機能】
1. ダッシュボード：サマリー表示
2. 日報登録：AIで解析して保存
3. 商談一覧：検索・フィルタリング
4. Excelエクスポート

上記のディレクトリ構成で作成してください。
```

**Cursorが全て作ってくれます！**

---

## スライド8：Cursorでの実装とデバッグ

### Composerモードの活用

**Composerとは？**
- 複数ファイルを同時に作成・編集できる強力な機能
- プロジェクト全体を理解してコード生成
- 大規模な変更も一度に実行可能

**Chatとの違い**
```
Chat：
- 質問・回答
- コードの断片を提示
- 1ファイルずつ対応

Composer：
- 実際にファイルを作成・編集
- プロジェクト全体を把握
- 複数ファイルを一括処理
```

### 効果的なプロンプトの書き方

**基本原則**

**1. 具体的に書く**
```
❌ 悪い例：
「営業管理システムを作って」

✓ 良い例：
「営業日報をブラウザから入力し、OpenAI APIで情報を抽出して
データベースに保存するWebアプリを作成してください。
技術スタック：Flask、SQLite、Bootstrap」
```

**2. 段階的に指示する**
```
一度に全部作ろうとしない！

ステップ1：基本構造を作成
「Flaskアプリの基本構造を作成してください。
ダッシュボードと日報登録の2つのページを用意。」

ステップ2：機能を追加
「日報登録ページにOpenAI API連携を追加してください。」

ステップ3：データベース追加
「商談データをSQLiteに保存する機能を追加してください。」
```

**3. 制約条件を明示する**
```
「以下の制約条件でお願いします：
- Pythonのバージョンは3.10
- 環境変数で APIキーを管理
- エラーハンドリングを含める
- コメントを日本語で記述」
```

**4. 例を示す**
```
「入力例：
本日ABC社を訪問。在庫管理システムを提案、予算500万円。

出力例：
{
  "customer_name": "ABC社",
  "summary": "在庫管理システム提案",
  "amount": 5000000
}

この形式で処理してください。」
```

### 実装時の具体的な流れ

**シナリオ：Webアプリを一から作る**

**ステップ1：プロジェクト初期化**
```
Composerに指示：
「sales-report-webという名前でFlaskプロジェクトを作成してください。
以下のファイル構成で：
- app.py（メインアプリ）
- models.py（データベース定義）
- templates/dashboard.html
- requirements.txt

まずは「Hello World」が表示される最小構成でお願いします。」
```

**ステップ2：動作確認**
```
ターミナルで実行：
$ python app.py

ブラウザで確認：
http://localhost:5000

→ 表示されればOK！
```

**ステップ3：機能追加**
```
Composerに指示：
「日報登録フォームを追加してください。
- /report パスで表示
- テキストエリアでフォームを入力
- 送信ボタンをクリックで /api/analyze に POST
- 現時点ではダミーレスポンスでOK」
```

**ステップ4：AI連携**
```
Composerに指示：
「/api/analyze エンドポイントにOpenAI API連携を追加してください。
- 環境変数 OPENAI_API_KEY からAPIキー取得
- gpt-4o-mini モデルを使用
- [前述のプロンプト]で情報抽出
- JSON形式で返却」
```

**ステップ5：データベース保存**
```
Composerに指示：
「抽出した情報をSQLiteに保存する機能を追加してください。
- models.pyに Deal モデルを定義
- /api/analyze で保存処理を追加
- ダッシュボードに最新10件を表示」
```

### エラーが出たときの対処法

**エラー対応の基本フロー**

**1. エラーメッセージを確認**
```
例：
Traceback (most recent call last):
  File "app.py", line 45, in analyze
    result = extract_info(text)
  File "ai_extractor.py", line 12, in extract_info
    response = openai.ChatCompletion.create(...)
openai.error.AuthenticationError: Invalid API key
```

**2. Cursorのチャットにエラーを貼り付け**
```
チャットに入力：
「以下のエラーが出ました。原因と解決方法を教えてください。

[エラーメッセージを貼り付け]
```

**3. AIの分析結果を確認**
```
Cursorの回答例：
「OpenAI APIキーが無効または設定されていません。

解決方法：
1. .envファイルを作成
2. OPENAI_API_KEY=sk-... を記載
3. python-dotenvで読み込み

修正箇所を提示しますか？」
```

**4. 修正を適用**
```
「はい、修正してください」
→ AIが自動で修正してくれる
```

### デバッグの実践テクニック

**テクニック1：ログ出力**
```python
# どこで処理が止まっているか確認
print(f"受信したテキスト: {text}")
print(f"API呼び出し開始")
result = call_openai_api(text)
print(f"API結果: {result}")
```

**テクニック2：段階的に確認**
```
1. まず静的なデータで動作確認
2. 次にAPIを実際に呼ぶ
3. 最後にデータベースに保存

→ どこで問題が起きているか特定しやすい
```

**テクニック3：Cursorに分析させる**
```
コードを選択してチャットに：
「このコードでエラーが出る可能性がある箇所を指摘してください」

→ AIが潜在的なバグを指摘してくれる
```

### APIデバッグの基本

**Webアプリのデバッグツール**

**1. ブラウザの開発者ツール**
```
Chrome/Edgeで F12 キーを押す

【Networkタブ】
- APIリクエストの確認
- レスポンスの内容確認
- エラーステータスコード確認

【Consoleタブ】
- JavaScriptのエラー確認
- console.log()の出力確認
```

**2. Postman（API テストツール）**
```
用途：
- APIを直接テスト
- フロントエンドなしで動作確認
- リクエスト・レスポンスを詳細に確認

例：
POST http://localhost:5000/api/analyze
Body: {"text": "ABC社訪問..."}

→ レスポンスを確認
```

**3. Flaskのデバッグモード**
```python
# app.py
if __name__ == '__main__':
    app.run(debug=True)  # デバッグモード有効

メリット：
- エラー時に詳細情報が表示される
- コード変更時に自動リロード
```

### よくあるエラーと対処法

**エラー1：ModuleNotFoundError**
```
原因：必要なライブラリがインストールされていない

解決：
$ pip install [ライブラリ名]
```

**エラー2：OpenAI API エラー**
```
原因：APIキーが無効、または使用量上限

解決：
- APIキーを確認
- OpenAIのダッシュボードで使用量確認
```

**エラー3：データベースエラー**
```
原因：テーブルが作成されていない

解決：
Composerに「データベース初期化処理を追加してください」
```

**困ったら常にCursorに聞く！**
- エラーメッセージをコピー
- チャットに貼り付け
- 原因と解決策を聞く
- これが最速の解決方法

---

## スライド9：Renderへのデプロイ

### Renderとは？

**無料で使えるクラウドサービス**
- Webアプリをインターネット上に公開できる
- サーバー管理不要（フルマネージド）
- GitHubと連携して自動デプロイ

**料金プラン**
```
無料プラン：
- Webサービス：使用可能（制限あり）
- PostgreSQLデータベース：90日間
- 独自ドメイン：使用可能
- SSL（https）：自動で有効

制限：
- アクセスがないと自動スリープ（初回アクセスが遅くなる）
- 月750時間まで無料

有料プラン（$7/月〜）：
- スリープなし
- より高速
- データベース永続化
```

**他のサービスとの比較**
```
Heroku：かつては無料だったが現在は有料のみ
Vercel：フロントエンド特化（今回は不向き）
Railway：Renderと似ているが少し複雑
Render：バランスが良く初心者に最適 ✓
```

### デプロイの準備

**1. GitHubアカウント作成**
```
https://github.com にアクセスして登録
→ コードをオンラインで管理するサービス
```

**2. コードをGitHubにアップロード**

Cursorのターミナルで：
```bash
# Git初期化
$ git init

# ファイルを追加
$ git add .

# コミット（変更を記録）
$ git commit -m "Initial commit"

# GitHubに接続
$ git remote add origin https://github.com/[ユーザー名]/sales-report-web.git

# アップロード
$ git push -u origin main
```

**3. 必要なファイルの確認**

**requirements.txt**（必須）
```
Flask==3.0.0
openai==1.3.0
python-dotenv==1.0.0
psycopg2-binary==2.9.9
gunicorn==21.2.0
```

**render.yaml**（推奨）
```yaml
services:
  - type: web
    name: sales-report-web
    env: python
    buildCommand: "pip install -r requirements.txt"
    startCommand: "gunicorn app:app"
    envVars:
      - key: OPENAI_API_KEY
        sync: false
      - key: DATABASE_URL
        fromDatabase:
          name: sales-db
          property: connectionString

databases:
  - name: sales-db
    databaseName: sales_reports
    user: sales_user
```

**これらのファイルもCursorに作らせる！**
```
Composerに指示：
「Renderへのデプロイに必要な設定ファイルを作成してください。
- requirements.txt
- render.yaml
- PostgreSQL対応のコード修正
」
```

### Renderでのデプロイ手順

**ステップ1：Renderアカウント作成**
```
1. https://render.com にアクセス
2. 「Get Started」をクリック
3. GitHubアカウントで登録
```

**ステップ2：新しいWebサービスを作成**
```
1. Renderダッシュボードで「New +」をクリック
2. 「Web Service」を選択
3. GitHubリポジトリを連携
4. 作成したリポジトリを選択
```

**ステップ3：設定**
```
Name: sales-report-web
Environment: Python 3
Build Command: pip install -r requirements.txt
Start Command: gunicorn app:app

→ 「Create Web Service」をクリック
```

**ステップ4：データベース作成**
```
1. 「New +」→「PostgreSQL」を選択
2. Name: sales-db
3. Database: sales_reports
4. User: sales_user
5. Region: 最も近いリージョン（Oregon推奨）

→ 「Create Database」をクリック
```

**ステップ5：環境変数の設定**
```
Web Serviceの設定画面で：

Environment Variables:
1. OPENAI_API_KEY = sk-your-api-key-here
2. DATABASE_URL = [PostgreSQLの接続URL]
   （自動で設定される）

→ 「Save Changes」
```

**ステップ6：デプロイ実行**
```
自動的にデプロイが開始される

ログを確認：
- ビルド中...
- 依存関係をインストール中...
- アプリケーション起動...
- ✓ デプロイ成功！

→ URLが発行される
   例：https://sales-report-web.onrender.com
```

### デプロイ後の確認

**1. URLにアクセス**
```
発行されたURLをブラウザで開く
→ アプリが表示されればOK！
```

**2. 機能テスト**
```
- 日報登録が動作するか
- データベースに保存されるか
- 一覧表示が正しいか
```

**3. チームメンバーに共有**
```
URLを社内チャットやメールで共有
→ 誰でもブラウザからアクセス可能！
```

### よくあるデプロイエラーと対処法

**エラー1：ビルド失敗**
```
原因：requirements.txtの記述ミス

解決：
- ローカルで pip install -r requirements.txt を実行
- エラーが出なければOK
- エラーが出たらCursorに修正依頼
```

**エラー2：アプリが起動しない**
```
原因：Gunicornの設定ミス、またはポート設定

解決：
Start Command を確認：
gunicorn app:app --bind 0.0.0.0:$PORT
```

**エラー3：データベース接続エラー**
```
原因：DATABASE_URLが正しく設定されていない

解決：
- Environment Variablesを確認
- PostgreSQLが作成されているか確認
```

**エラー4：OpenAI APIエラー**
```
原因：OPENAI_API_KEYが設定されていない

解決：
- Environment Variablesに追加
- 値を間違えていないか確認
```

### 更新（再デプロイ）の方法

**コードを修正したら**

```bash
# 1. GitHubにプッシュ
$ git add .
$ git commit -m "機能追加"
$ git push

# 2. Renderが自動でデプロイ
→ 数分待つだけ！
```

**手動デプロイ**
```
Render画面で「Manual Deploy」ボタンをクリック
→ 最新のコードで再デプロイ
```

### 運用のポイント

**1. ログの確認**
```
Render画面の「Logs」タブ
→ エラーが出ていないかチェック
```

**2. 使用量の確認**
```
- Renderの無料枠は月750時間
- OpenAI APIの使用量も定期的に確認
```

**3. バックアップ**
```
データベースのバックアップ：
- Renderの管理画面からエクスポート可能
- 定期的にダウンロード推奨
```

**4. セキュリティ**
```
- APIキーは絶対にGitHubにコミットしない
- 環境変数で管理
- .envファイルは .gitignore に追加
```

### 独自ドメインの設定（オプション）

**自社ドメインを使いたい場合**
```
1. ドメインを取得（お名前.comなど）
2. Render画面で「Custom Domain」を追加
3. DNSレコードを設定

例：
sales-report.yourcompany.com
→ アプリにアクセスできる
```

**これで完成！**
チーム全員がブラウザから営業日報ツールを使えるようになりました。

---

## スライド10：まとめと実践への道

### 学習のポイント振り返り

**あなたが習得したこと**

**1. AI活用開発の基礎**
- ✅ Cursorを使ったAIペアプログラミング
- ✅ プロンプトの書き方
- ✅ AIにコードを生成させる方法
- ✅ エラーをAIに解析させるデバッグ手法

**2. ローカルツール開発**
- ✅ Pythonスクリプトの作成
- ✅ OpenAI APIでのテキスト解析
- ✅ Excelファイルの自動生成
- ✅ 実務で即使えるツールの完成

**3. Webアプリ開発**
- ✅ データベース設計の基本
- ✅ Webアプリの構成理解
- ✅ Flask/FastAPIでのバックエンド開発
- ✅ フロントエンドの基礎

**4. クラウドデプロイ**
- ✅ GitHubでのコード管理
- ✅ Renderへのデプロイ
- ✅ チーム全体で使えるシステムの完成

### 重要な考え方

**1. 完璧を目指さない**
```
❌ 最初から完璧なシステムを作ろうとする
✓ まず動くものを作り、徐々に改善する

「動くけど汚いコード」でOK
→ 後でCursorにリファクタリングさせる
```

**2. AIを信頼しすぎない**
```
❌ AIが生成したコードをそのまま使う
✓ 動作確認してから使う

AIもミスをする：
- 古い情報を使うことがある
- セキュリティ上の問題があることも
- 必ず自分で確認する習慣を
```

**3. 小さく始めて大きく育てる**
```
フェーズ1：自分だけのローカルツール
  ↓ 使いながら改善
フェーズ2：チーム内で試験運用
  ↓ フィードバックを反映
フェーズ3：部門全体で本格運用
  ↓ 継続的な改善
```

**4. 業務知識が最大の武器**
```
エンジニアにはない強み：
- 現場の課題を深く理解している
- どんなツールが本当に役立つか分かる
- ユーザー視点でシステムを設計できる

技術 × 業務知識 = 最強のツール
```

### 次に作れるツールのアイデア

**営業部門向け**

**1. 顧客問い合わせ自動分類ツール**
```
機能：
- メールやチャットの問い合わせをAIが自動分類
- 緊急度を判定
- 適切な担当者に自動振り分け
- 回答テンプレートを提案

効果：
- 問い合わせ対応時間 50%削減
- 対応漏れゼロ
```

**2. 見積書自動生成システム**
```
機能：
- 顧客情報と要件を入力
- 過去の類似案件をAIが検索
- 適切な価格を提案
- Word/PDF形式で見積書を自動生成

効果：
- 見積作成時間 80%削減
- 価格設定の標準化
```

**3. 商談議事録自動作成ツール**
```
機能：
- 商談の音声を録音
- AIが文字起こし
- 重要ポイントを自動抽出
- 議事録フォーマットで整形

効果：
- 議事録作成時間 90%削減
- 重要情報の漏れ防止
```

**業務部門向け**

**4. 契約書自動チェックツール**
```
機能：
- 契約書PDFをアップロード
- AIが重要条項を自動抽出
- リスク項目を強調表示
- 過去の契約書と比較分析

効果：
- チェック時間 70%削減
- リスク発見率向上
```

**5. 経費申請自動処理システム**
```
機能：
- 領収書を撮影
- OCR + AIで内容を自動読み取り
- 経費項目を自動分類
- 申請書を自動生成

効果：
- 経費申請の手間 90%削減
- 入力ミス削減
```

**6. 在庫管理アラートシステム**
```
機能：
- 在庫データを定期的に確認
- AIが需要を予測
- 発注タイミングを自動通知
- 過剰在庫・欠品を予防

効果：
- 在庫最適化
- 発注作業の効率化
```

**部門横断**

**7. 社内FAQ自動回答ボット**
```
機能：
- 社内規定や手順書を学習
- チャットで質問すると自動回答
- 該当する規定ページへのリンクも提示

効果：
- 問い合わせ対応の負担削減
- 新人教育の効率化
```

**8. 定例レポート自動生成ツール**
```
機能：
- 各種データソースから自動収集
- AIが傾向分析とコメント生成
- グラフ・表を自動作成
- PowerPoint形式で出力

効果：
- レポート作成時間 80%削減
- データに基づく意思決定
```

### 開発のステップ

**新しいツールを作るときの手順**

**1. 課題の明確化（1日）**
```
- 何が問題なのか？
- 現状どれだけ時間がかかっているか？
- 自動化できる部分は？
- 最低限必要な機能は？
```

**2. 要件定義（1日）**
```
- 入力は何か？
- 出力は何か？
- どんなデータが必要か？
- 誰が使うか？
```

**3. ローカル版開発（2-3日）**
```
- Cursorで基本機能を実装
- 自分で使って動作確認
- 改善を繰り返す
```

**4. Web化（2-3日）**
```
- データベース設計
- Web画面作成
- API実装
```

**5. テスト運用（1週間）**
```
- 少人数で試用
- フィードバック収集
- バグ修正
```

**6. 本番展開**
```
- Renderにデプロイ
- チーム全体に展開
- 使い方説明会
```

**合計：2-3週間で新しいツールが完成！**

### 継続学習のリソース

**公式ドキュメント**
```
Cursor:
https://docs.cursor.com/

OpenAI API:
https://platform.openai.com/docs

Flask:
https://flask.palletsprojects.com/

Render:
https://render.com/docs
```

**学習サイト**
```
Udemy：
- Python入門コース
- Flask Webアプリ開発コース

YouTube：
- Cursor使い方チュートリアル
- AI開発入門動画

Qiita：
- 日本語の技術記事が豊富
```

**コミュニティ**
```
Discord/Slack：
- Cursor Users Community
- AI開発コミュニティ

X（Twitter）：
- #Cursor #AI開発 で情報収集
```

**困ったときの相談先**
```
1. Cursorに聞く（最速）
2. ChatGPTに聞く
3. Stack Overflow（英語）
4. Qiita（日本語）
5. 社内の詳しい人
```

### 最後に：あなたならできる

**プログラミング未経験だったあなたが...**

**Before（受講前）**
```
- システム開発は専門家の仕事
- 外注するしかない
- 改善に時間とコストがかかる
- 自分にはできないと思っていた
```

**After（受講後）**
```
✓ 自分で業務効率化ツールを作れる
✓ AIを活用して開発できる
✓ チーム全体で使えるシステムを構築できる
✓ 継続的に改善・機能追加できる
```

**これからの時代**
```
AI活用スキル = 必須のビジネススキル

「システムを作る」能力は
もはや特別なスキルではなく、
誰もが持つべき基本スキルになります。
```

**最初の一歩を踏み出したあなたへ**

```
おめでとうございます！

このカリキュラムを通じて、
あなたは「システムを作る側」の人間になりました。

明日から、あなたの業務を
あなた自身の手で効率化してください。

そして、その成功体験を周りに広げてください。

一人ひとりが自分のツールを作れる組織は、
圧倒的に強い組織です。

Good luck & Happy coding!
```

---

## 付録：クイックリファレンス

### Cursorの基本操作

```
Chat: Cmd/Ctrl + L
Composer: Cmd/Ctrl + I
ファイル検索: Cmd/Ctrl + P
```

### よく使うコマンド

```bash
# Python環境
python --version
pip install -r requirements.txt
python app.py

# Git操作
git add .
git commit -m "message"
git push

# 仮想環境
python -m venv venv
source venv/bin/activate  # Mac/Linux
venv\Scripts\activate     # Windows
```

### OpenAI API基本

```python
from openai import OpenAI
client = OpenAI(api_key="your-key")

response = client.chat.completions.create(
    model="gpt-4o-mini",
    messages=[{"role": "user", "content": "質問"}]
)
```

### Flask基本

```python
from flask import Flask, render_template, request

app = Flask(__name__)

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/api/data', methods=['POST'])
def api():
    data = request.json
    return {"result": "success"}

if __name__ == '__main__':
    app.run(debug=True)
```

---

**カリキュラム完**

あなたの成功を心から応援しています！

